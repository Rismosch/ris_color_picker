<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ris_color_picker</title>
    <style>
        :root{
            --pico-8-black:         #000000;
            --pico-8-blue:          #1d2b53;
            --pico-8-purple:        #7e2553;
            --pico-8-green:         #008751;
            --pico-8-brown:         #ab5236;
            --pico-8-dark-grey:     #5f574f;
            --pico-8-light-grey:    #c2c3c7;
            --pico-8-white:         #fff1e8;
            --pico-8-red:           #ff004d;
            --pico-8-orange:        #ffa300;
            --pico-8-yellow:        #ffec27;
            --pico-8-lime:          #00e436;
            --pico-8-cyan:          #29adff;
            --pico-8-washed-grey:   #83769c;
            --pico-8-pink:          #ff77a8;
            --pico-8-flesh:         #ffccaa;
        }

        .canvas {
            border: 1px solid var(--pico-8-dark-grey);
        }

        .centered {
            display: flex;
            align-items: center;
            margin: 5px;
        }

        .label {
            width: 10px;
            margin: 0px 0px 0px 5px;
            user-select: none;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer/Edge */
        }

        .slider {
            margin: 0px 10px 0px 10px;
        }

        .text_field {
            width: 75px;
        }

    </style>
</head>
<body style="background: var(--pico-8-white); font-family: Arial, sans-serif;">
    <div id="javascript_content" style="display: none">
        <!--canvas-->
        <table style="display: inline-block">
            <tr>
                <td><canvas id="canvas_xy" class="canvas" width="256" height="256"></canvas></td>
                <td><canvas id="canvas_z" class="canvas" width="20" height="256"></canvas></td>
            </tr>
        </table>

        <!--sliders-->
        <table style="display: inline-block">
            <tr>
                <td colspan="3">
                    <select id="clamp_dropdown">
                        <option value="clamp">clamp invalid colors</option>
                        <option value="hide">hide invalid colors</option>
                    </select>
                </td>
                <td>
                    <select id="format_dropdown" class="text_field">
                        <option value="normalized">0..1</option>
                        <option value="byte">0..255</option>
                    </select>
                </td>
                <td></td>
            </tr>
            <tr>
                <td><input type="radio" id="radio_r" name="z_coord" value="r"></td>
                <td><span class="label" title="Red">R</span></td>
                <td><input type="range" id="slider_r" class="slider" min="0" max="1" step="0.004"></td>
                <td>
                    <input type="number" id="byte_field_r" class="text_field" min="0" max="255" step="1" oninput="handle_rgb_input(this, true)">
                    <input type="number" id="normalized_field_r" class="text_field" min="0" max="1" step="0.004" oninput="handle_rgb_input(this, false)">
                </td>
                <td><span class="label" id="warning_r" title="this color is outside the sRGB space">&#9888;</span></td>
            </tr>
            <tr>
                <td><input type="radio" id="radio_g" name="z_coord" value="g"></td>
                <td><span class="label" title="Green">G</span></td>
                <td><input type="range" id="slider_g" class="slider" min="0" max="1" step="0.004"></td>
                <td>
                    <input type="number" id="byte_field_g" class="text_field" min="0" max="255" oninput="handle_rgb_input(this, true)">
                    <input type="number" id="normalized_field_g" class="text_field" min="0" max="1" step="0.004" oninput="handle_rgb_input(this, false)">
                </td>
                <td><span class="label" id="warning_g" title="this color is outside the sRGB space">&#9888;</span></td>
            </tr>
            <tr>
                <td><input type="radio" id="radio_b" name="z_coord" value="b"></td>
                <td><span class="label" title="Blue">B</span></td>
                <td><input type="range" id="slider_b" class="slider" min="0" max="1" step="0.004"></td>
                <td>
                    <input type="number" id="byte_field_b" class="text_field" min="0" max="255" oninput="handle_rgb_input(this, true)">
                    <input type="number" id="normalized_field_b" class="text_field" min="0" max="1" step="0.004" oninput="handle_rgb_input(this, false)">
                </td>
                <td><span class="label" id="warning_b" title="this color is outside the sRGB space">&#9888;</span></td>
            </tr>
            <tr>
                <td><input type="radio" id="radio_l" name="z_coord" value="l"></td>
                <td><span class="label" title="OkLab Luminocity">L</span></td>
                <td><input type="range" id="slider_l" class="slider" min="0" max="1" step="0.004"></td>
                <td>
                    <input type="number" id="normalized_field_l" class="text_field" min="0" max="1" step="0.004" oninput="handle_lch_input(this)">
                </td>
                <td></td>
            </tr>
            <tr>
                <td><input type="radio" id="radio_c" name="z_coord" value="c"></td>
                <td><span class="label" title="OkLab Chroma">C</span></td>
                <td><input type="range" id="slider_c" class="slider" min="0" max="0.4" step="0.004"></td>
                <td>
                    <input type="number" id="normalized_field_c" class="text_field" min="0" max="0.4" step="0.004" oninput="handle_lch_input(this)">
                </td>
                <td></td>
            </tr>
            <tr>
                <td><input type="radio" id="radio_h" name="z_coord" value="h"></td>
                <td><span class="label" title="OkLab Hue">H</span></td>
                <td><input type="range" id="slider_h" class="slider" min="-3.142" max="3.142" step="0.001"></td>
                <td>
                    <input type="number" id="normalized_field_h" class="text_field" min="-3.142" max="3.142" step="0.001" oninput="handle_lch_input(this)">
                </td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td colspan="2"><span class="label">Hex Code</span></td>
                <td><input type="text" id="hex_field" class="text_field" oninput="handle_hex_input(this)"></td>
                <td></td>
            </tr>
        </table>

        <!--interpolation-->
        <div>
        <button onclick="reset_everything()">Reset</Button>
        </div>

    </div>
    <noscript>
        <p>You need to enable JavaScript for this page to work &#9757;&#129299;</p>
    </noscript>
    <script>
        // enable color picker
        const javascript_content = document.getElementById("javascript_content");
        javascript_content.style.display = "inline";

        // cookie
        const cookie_name = "ris_color_picker_cookie";
        let cookie;
        function set_cookie_to_default() {
            cookie = {
                selected_z: "h", // r, g, b, l, c, h,
                clamp_invalid_colors: true,
                color_l: 0.876,
                color_a: +0.01880542582664133,
                color_b: -0.05697680194148045,
                format_field: "normalized", // "normalized", "byte",
            }
        }

        // get elements
        const canvas_xy = document.getElementById("canvas_xy");
        const canvas_z = document.getElementById("canvas_z");
        const clamp_dropdown = document.getElementById("clamp_dropdown");
        const format_dropdown = document.getElementById("format_dropdown");
        const slider_r = document.getElementById("slider_r");
        const slider_g = document.getElementById("slider_g");
        const slider_b = document.getElementById("slider_b");
        const slider_l = document.getElementById("slider_l");
        const slider_c = document.getElementById("slider_c");
        const slider_h = document.getElementById("slider_h");
        const byte_field_r = document.getElementById("byte_field_r");
        const byte_field_g = document.getElementById("byte_field_g");
        const byte_field_b = document.getElementById("byte_field_b");
        const normalized_field_r = document.getElementById("normalized_field_r");
        const normalized_field_g = document.getElementById("normalized_field_g");
        const normalized_field_b = document.getElementById("normalized_field_b");
        const normalized_field_l = document.getElementById("normalized_field_l");
        const normalized_field_c = document.getElementById("normalized_field_c");
        const normalized_field_h = document.getElementById("normalized_field_h");
        const hex_field = document.getElementById("hex_field");
        const warning_r = document.getElementById("warning_r");
        const warning_g = document.getElementById("warning_g");
        const warning_b = document.getElementById("warning_b");

        // initialize canvas
        const ctx_xy = canvas_xy.getContext('2d');
        const ctx_z = canvas_z.getContext('2d');
        const rect_xy = canvas_xy.getBoundingClientRect();
        const rect_z = canvas_z.getBoundingClientRect();

        let is_dragging_xy = false;
        let is_dragging_z = false;

        document.body.addEventListener('mousemove', (e) => {
            if (is_dragging_xy) {
                drag_xy(e);
            } else if (is_dragging_z) {
                drag_z(e);
            }
        });

        javascript_content.addEventListener('mouseup', (e) => {
            is_dragging_xy = false;
            is_dragging_z = false;
        });

        canvas_xy.addEventListener('mousedown', (e) => {
            is_dragging_xy = true;
            drag_xy(e);
        });

        canvas_z.addEventListener('mousedown', (e) => {
            is_dragging_z = true;
            drag_z(e);
        });

        function drag_xy(e) {
            const x = e.clientX - rect_xy.left;
            const y = canvas_xy.height - e.clientY + rect_xy.top;
            let normalized_x = x / canvas_xy.width;
            let normalized_y = y / canvas_xy.height;

            if (normalized_x < 0) {
                normalized_x = 0;
            }
            if (normalized_x > 1) {
                normalized_x = 1;
            }
            if (normalized_y < 0) {
                normalized_y = 0;
            }
            if (normalized_y > 1) {
                normalized_y = 1;
            }

            switch(cookie.selected_z) {
                case "r":
                    byte_field_g.value = Math.round(normalized_x * 255);
                    byte_field_b.value = Math.round(normalized_y * 255);
                    normalized_field_g.value = normalized_x.toFixed(3);
                    normalized_field_b.value = normalized_y.toFixed(3);
                    update_lch();
                    break;
                case "g":
                    byte_field_r.value = Math.round(normalized_x * 255);
                    byte_field_b.value = Math.round(normalized_y * 255);
                    normalized_field_r.value = normalized_x.toFixed(3);
                    normalized_field_b.value = normalized_y.toFixed(3);
                    update_lch();
                    break;
                case "b":
                    byte_field_r.value = Math.round(normalized_x * 255);
                    byte_field_g.value = Math.round(normalized_y * 255);
                    normalized_field_r.value = normalized_x.toFixed(3);
                    normalized_field_g.value = normalized_y.toFixed(3);
                    update_lch();
                    break;
                case "l": {
                    normalized_field_c.value = (normalized_x * 0.4).toFixed(3);
                    normalized_field_h.value = (normalized_y * 2 * Math.PI - Math.PI).toFixed(3);
                    update_rgb();
                    break;
                }
                case "c": {
                    normalized_field_l.value = (normalized_x).toFixed(3);
                    normalized_field_h.value = (normalized_y * 2 * Math.PI - Math.PI).toFixed(3);
                    update_rgb();
                    break;
                }
                case "h": {
                    normalized_field_l.value = (normalized_x).toFixed(3);
                    normalized_field_c.value = (normalized_y * 0.4).toFixed(3);
                    update_rgb();
                    break;
                }
            }

            slider_r.value = normalized_field_r.value;
            slider_g.value = normalized_field_g.value;
            slider_b.value = normalized_field_b.value;
            slider_l.value = normalized_field_l.value;
            slider_c.value = normalized_field_c.value;
            slider_h.value = normalized_field_h.value;

            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        }

        function drag_z(e) {
            const y = canvas_xy.height - e.clientY + rect_xy.top;
            let normalized_y = y / canvas_xy.height;

            if (normalized_y < 0) {
                normalized_y = 0;
            }
            if (normalized_y > 1) {
                normalized_y = 1;
            }

            switch(cookie.selected_z) {
                case "r":
                    byte_field_r.value = Math.round(normalized_y * 255);
                    normalized_field_r.value = normalized_y.toFixed(3);
                    update_lch();
                    break;
                case "g":
                    byte_field_g.value = Math.round(normalized_y * 255);
                    normalized_field_g.value = normalized_y.toFixed(3);
                    update_lch();
                    break;
                case "b":
                    byte_field_b.value = Math.round(normalized_y * 255);
                    normalized_field_b.value = normalized_y.toFixed(3);
                    update_lch();
                    break;
                case "l": {
                    normalized_field_l.value = (normalized_y).toFixed(3);
                    update_rgb();
                    break;
                }
                case "c": {
                    normalized_field_c.value = (normalized_y * 0.4).toFixed(3);
                    update_rgb();
                    break;
                }
                case "h": {
                    normalized_field_h.value = (normalized_y * 2 * Math.PI - Math.PI).toFixed(3);
                    update_rgb();
                    break;
                }
            }

            slider_r.value = normalized_field_r.value;
            slider_g.value = normalized_field_g.value;
            slider_b.value = normalized_field_b.value;
            slider_l.value = normalized_field_l.value;
            slider_c.value = normalized_field_c.value;
            slider_h.value = normalized_field_h.value;

            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        }

        // initialize dropdowns
        clamp_dropdown.addEventListener("change", clamp_dropdown_change_callback)
        format_dropdown.addEventListener("change", format_dropdown_change_callback);

        // initialize radio
        const radios = document.querySelectorAll('input[name="z_coord"]');
        radios.forEach(radio => {
            radio.addEventListener('change', function () {
                if (this.checked) {
                    cookie.selected_z = this.value;
                    save_cookie();
                    update_canvas();
                    update_color();
                    save_cookie();
                }
            });
        });

        // initialize slider
        slider_r.addEventListener("input", function () {
            normalized_field_r.value = slider_r.value;
            byte_field_r.value = Math.round(slider_r.value * 255);
            update_lch();
            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        });
        slider_g.addEventListener("input", function () {
            normalized_field_g.value = slider_g.value;
            byte_field_g.value = Math.round(slider_g.value * 255);
            update_lch();
            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        });
        slider_b.addEventListener("input", function () {
            normalized_field_b.value = slider_b.value;
            byte_field_b.value = Math.round(slider_b.value * 255);
            update_lch();
            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        });
        slider_l.addEventListener("input", function () {
            normalized_field_l.value = slider_l.value;
            update_rgb();
            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        });
        slider_c.addEventListener("input", function () {
            normalized_field_c.value = slider_c.value;
            update_rgb();
            update_hex();
            update_canvas();
            update_color()
            save_cookie();
        });
        slider_h.addEventListener("input", function () {
            normalized_field_h.value = slider_h.value;
            update_rgb();
            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        });

        // initialize everthing
        initialize_everything();
        function initialize_everything() {
            read_cookie();

            const lab = {
                l: cookie.color_l,
                a: cookie.color_a,
                b: cookie.color_b,
            };
            const lch = oklab_to_oklch(lab);
            const normalized_rgb = oklab_to_linear_srgb(lab);
            const byte_rgb = {
                r: Math.round(normalized_rgb.r * 255),
                g: Math.round(normalized_rgb.g * 255),
                b: Math.round(normalized_rgb.b * 255),
            };

            slider_r.value = normalized_rgb.r;
            slider_g.value = normalized_rgb.g;
            slider_b.value = normalized_rgb.b;
            slider_l.value = lch.l;
            slider_c.value = lch.c;
            slider_h.value = lch.h;
            byte_field_r.value = byte_rgb.r;
            byte_field_g.value = byte_rgb.g;
            byte_field_b.value = byte_rgb.b;
            normalized_field_r.value = normalized_rgb.r.toFixed(3);
            normalized_field_g.value = normalized_rgb.g.toFixed(3);
            normalized_field_b.value = normalized_rgb.b.toFixed(3);
            normalized_field_l.value = lch.l.toFixed(3);
            normalized_field_c.value = lch.c.toFixed(3);
            normalized_field_h.value = lch.h.toFixed(3);

            update_canvas();
            update_hex();

            clamp_dropdown.value = cookie.clamp_invalid_colors ? "clamp" : "hide";
            format_dropdown.value = cookie.format_field;

            clamp_dropdown_change_callback();
            format_dropdown_change_callback();

            document.querySelector(`input[name="z_coord"][value="${cookie.selected_z}"]`).checked = true;
        }

        // callbacks
        function update_rgb() {
            const lch = {
                l: Number(normalized_field_l.value),
                h: Number(normalized_field_h.value),
                c: Number(normalized_field_c.value),
            };
            const rgb = oklch_to_linear_srgb(lch);

            normalized_field_r.value = rgb.r.toFixed(3);
            normalized_field_g.value = rgb.g.toFixed(3);
            normalized_field_b.value = rgb.b.toFixed(3);
            byte_field_r.value = Math.round(rgb.r * 255);
            byte_field_g.value = Math.round(rgb.g * 255);
            byte_field_b.value = Math.round(rgb.b * 255);
            slider_r.value = normalized_field_r.value;
            slider_g.value = normalized_field_g.value;
            slider_b.value = normalized_field_b.value;
        }

        function update_lch() {
            const rgb = {
                r: Number(normalized_field_r.value),
                g: Number(normalized_field_g.value),
                b: Number(normalized_field_b.value),
            };
            const lch = linear_srgb_to_oklch(rgb);

            normalized_field_l.value = lch.l.toFixed(3);
            normalized_field_c.value = lch.c.toFixed(3);
            normalized_field_h.value = lch.h.toFixed(3);
            slider_l.value = normalized_field_l.value;
            slider_c.value = normalized_field_c.value;
            slider_h.value = normalized_field_h.value;
        }

        function update_hex() {
            let r = Number(byte_field_r.value);
            let g = Number(byte_field_g.value);
            let b = Number(byte_field_b.value);

            let r_is_valid = true;
            let g_is_valid = true;
            let b_is_valid = true;
            if (r < 0) {
                r = 0;
                r_is_valid = false;
            }
            if (r > 255) {
                r = 255;
                r_is_valid = false;
            }
            if (g < 0) {
                g = 0;
                b_is_valid = false;
            }
            if (g > 255) {
                g = 255;
                g_is_valid = false;
            }
            if (b < 0) {
                b = 0;
                g_is_valid = false;
            }
            if (b > 255) {
                b = 255;
                b_is_valid = false;
            }

            warning_r.style.visibility = r_is_valid ? "hidden" : "visible";
            warning_g.style.visibility = g_is_valid ? "hidden" : "visible";
            warning_b.style.visibility = b_is_valid ? "hidden" : "visible";

            let hex_r = r.toString(16);
            if (hex_r.length == 1) {
                hex_r = `0${hex_r}`;
            }
            let hex_g = g.toString(16);
            if (hex_g.length == 1) {
                hex_g = `0${hex_g}`;
            }
            let hex_b = b.toString(16);
            if (hex_b.length == 1) {
                hex_b = `0${hex_b}`;
            }
            const hex_string = `${hex_r}${hex_g}${hex_b}`;
            hex_field.value = hex_string;
        }

        function update_color() {
            const lch = {
                l: Number(normalized_field_l.value),
                c: Number(normalized_field_c.value),
                h: Number(normalized_field_h.value),
            };
            const lab = oklch_to_oklab(lch);
            cookie.color_l = lab.l;
            cookie.color_a = lab.a;
            cookie.color_b = lab.b;
        }

        function clamp_dropdown_change_callback() {
            const selected_value = clamp_dropdown.value;
            cookie.clamp_invalid_colors = selected_value == "clamp";

            update_canvas();
            update_color();
            save_cookie();
        }

        function format_dropdown_change_callback() {
            const selected_value = format_dropdown.value;
            const show_byte_field = selected_value === "byte";
            const byte_display = show_byte_field ? "block" : "none";
            const normalized_display = show_byte_field ? "none" : "block";
            byte_field_r.style.display = byte_display;
            byte_field_g.style.display = byte_display;
            byte_field_b.style.display = byte_display;
            normalized_field_r.style.display = normalized_display;
            normalized_field_g.style.display = normalized_display;
            normalized_field_b.style.display = normalized_display;

            cookie.format_field = format_dropdown.value;
            save_cookie();
        }

        function handle_rgb_input(input, is_byte_field) {
            const number = is_byte_field
                ? parseInt(input.value)
                : parseFloat(input.value);

            if (isNaN(number)) {
                input.value = 0;
            } else if (number < input.min) {
                input.value = input.min;
            } else if (number > input.max) {
                input.value = input.max;
            }

            if (is_byte_field) {
                const byte_r = byte_field_r.value;
                const byte_g = byte_field_g.value;
                const byte_b = byte_field_b.value;
                const normalized_r = (byte_r / 255).toFixed(3);
                const normalized_g = (byte_g / 255).toFixed(3);
                const normalized_b = (byte_b / 255).toFixed(3);
                normalized_field_r.value = normalized_r;
                normalized_field_g.value = normalized_g;
                normalized_field_b.value = normalized_b;
            } else { // is_normalized_field
                const normalized_r = normalized_field_r.value;
                const normalized_g = normalized_field_g.value;
                const normalized_b = normalized_field_b.value;
                const byte_r = Math.round(normalized_r * 255);
                const byte_g = Math.round(normalized_g * 255);
                const byte_b = Math.round(normalized_b * 255);
                byte_field_r.value = byte_r;
                byte_field_g.value = byte_g;
                byte_field_b.value = byte_b;
            }

            slider_r.value = normalized_field_r.value;
            slider_g.value = normalized_field_g.value;
            slider_b.value = normalized_field_b.value;

            update_lch();
            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        }

        function handle_lch_input(input) {
            const number = parseFloat(input.value);

            if (isNaN(number)) {
                input.value = 0;
            } else if (number < input.min) {
                input.value = input.min;
            } else if (number > input.max) {
                input.value = input.max;
            }

            slider_l.value = normalized_field_l.value;
            slider_c.value = normalized_field_c.value;
            slider_h.value = normalized_field_h.value;

            update_rgb();
            update_hex();
            update_canvas();
            update_color();
            save_cookie();
        }

        function handle_hex_input(input) {
            let value = input.value.trim().substr(0, 6);
            for (let i = 0; i < value.length;) {
                let character = value[i];

                var is_hex = /^[0-9a-fA-F]+$/.test(character);
                if (!is_hex) {
                    value = `${value.slice(0, i)}${value.slice(i + 1)}`;
                } else {
                    i += 1;
                }
            }

            input.value = value;
            while (value.length < 6) {
                value = `${value}0`;
            }

            const hex_r = value.substr(0,2);
            const hex_g = value.substr(2,2);
            const hex_b = value.substr(4,2);

            const byte_r = parseInt(hex_r, 16);
            const byte_g = parseInt(hex_g, 16);
            const byte_b = parseInt(hex_b, 16);
            const normalized_r = byte_r / 255;
            const normalized_g = byte_g / 255;
            const normalized_b = byte_b / 255;
            const rgb = {
                r: normalized_r,
                g: normalized_g,
                b: normalized_b,
            }
            const lch = linear_srgb_to_oklch(rgb);

            byte_field_r.value = byte_r;
            byte_field_g.value = byte_g;
            byte_field_b.value = byte_b;
            normalized_field_r.value = rgb.r.toFixed(3);
            normalized_field_g.value = rgb.g.toFixed(3);
            normalized_field_b.value = rgb.b.toFixed(3);
            normalized_field_l.value = lch.l.toFixed(3);
            normalized_field_c.value = lch.c.toFixed(3);
            normalized_field_h.value = lch.h.toFixed(3);

            slider_r.value = normalized_field_r.value;
            slider_g.value = normalized_field_g.value;
            slider_b.value = normalized_field_b.value;
            slider_l.value = normalized_field_l.value;
            slider_c.value = normalized_field_c.value;
            slider_h.value = normalized_field_h.value;

            warning_r.style.visibility = "hidden";
            warning_g.style.visibility = "hidden";
            warning_b.style.visibility = "hidden";

            update_canvas();
            update_color();
            save_cookie();
        }

        function reset_everything() {
            clear_cookie();
            initialize_everything();
        }

        // canvas functions
        function update_canvas() {
            const byte_rgb = {
                r: Number(byte_field_r.value),
                g: Number(byte_field_g.value),
                b: Number(byte_field_b.value),
            };
            const normalized_rgb = {
                r: Number(normalized_field_r.value),
                g: Number(normalized_field_g.value),
                b: Number(normalized_field_b.value),
            };
            const lch = {
                l: Number(normalized_field_l.value),
                c: Number(normalized_field_c.value),
                h: Number(normalized_field_h.value),
            };

            // xy
            let width = canvas_xy.width;
            let height = canvas_xy.height;
            let imageData = ctx_xy.createImageData(width, height);
            let data = imageData.data;

            for (let y = 0; y <= height; ++y) {
                for (let x = 0; x < width; ++x) {
                    const inverted_y = height - y;
                    const i = (inverted_y * width + x) * 4; // each pixel has 4 values: r, g, b, a

                    const normalized_x = x / width;
                    const normalized_y = y / height;
                    let selected_x;
                    let selected_y;

                    switch (cookie.selected_z) {
                        case "r":
                            selected_x = byte_rgb.g;
                            selected_y = byte_rgb.b;
                            data[i + 0] = byte_rgb.r;
                            data[i + 1] = normalized_x * 255;
                            data[i + 2] = normalized_y * 255;
                            break;
                        case "g":
                            selected_x = byte_rgb.r;
                            selected_y = byte_rgb.b;
                            data[i + 0] = normalized_x * 255;
                            data[i + 1] = byte_rgb.g;
                            data[i + 2] = normalized_y * 255;
                            break;
                        case "b":
                            selected_x = byte_rgb.r;
                            selected_y = byte_rgb.g;
                            data[i + 0] = normalized_x * 255;
                            data[i + 1] = normalized_y * 255;
                            data[i + 2] = byte_rgb.b;
                            break;
                        case "l": {
                            selected_x = Math.round((lch.c / 0.4) * 255);
                            selected_y = Math.round(((lch.h + Math.PI) / (2 * Math.PI)) * 255);
                            const lch_ = {
                                l: lch.l,
                                c: normalized_x * 0.4,
                                h: normalized_y * 2 * Math.PI - Math.PI,
                            };
                            const normalized_rgb_ = clamp_rgb(oklch_to_linear_srgb(lch_));

                            data[i + 0] = normalized_rgb_.r * 255;
                            data[i + 1] = normalized_rgb_.g * 255;
                            data[i + 2] = normalized_rgb_.b * 255;
                            break;
                        }
                        case "c": {
                            selected_x = Math.round((lch.l) * 255);
                            selected_y = Math.round(((lch.h + Math.PI) / (2 * Math.PI)) * 255);
                            const lch_ = {
                                l: normalized_x,
                                c: lch.c,
                                h: normalized_y * 2 * Math.PI - Math.PI,
                            };
                            const rgb_ = clamp_rgb(oklch_to_linear_srgb(lch_));

                            data[i + 0] = rgb_.r * 255;
                            data[i + 1] = rgb_.g * 255;
                            data[i + 2] = rgb_.b * 255;
                            break;
                        }
                        case "h": {
                            selected_x = Math.round((lch.l) * 255);
                            selected_y = Math.round((lch.c / 0.4) * 255);
                            const lch_ = {
                                l: normalized_x,
                                c: normalized_y * 0.4,
                                h: lch.h,
                            };
                            const rgb_ = clamp_rgb(oklch_to_linear_srgb(lch_));

                            data[i + 0] = rgb_.r * 255;
                            data[i + 1] = rgb_.g * 255;
                            data[i + 2] = rgb_.b * 255;
                            break;
                        }
                    }

                    data[i + 3] = 255;

                    if (selected_x == x || selected_y == y) {
                        const data_rgb = {
                            r: data[i + 0] / 255,
                            g: data[i + 0] / 255,
                            b: data[i + 0] / 255,
                        };
                        const lab = linear_srgb_to_oklab(data_rgb);
                        if (lab.l > 0.9) {
                            data[i + 0] = 0;
                            data[i + 1] = 0;
                            data[i + 2] = 0;
                        } else if (lab.l < 0.8) {
                            data[i + 0] = 255;
                            data[i + 1] = 255;
                            data[i + 2] = 255;
                        } else {
                            const value = lab.l * 10 - 8;
                            data[i + 0] = 255 - value * 255;
                            data[i + 1] = 255 - value * 255;
                            data[i + 2] = 255 - value * 255;
                        }
                    }
                }
            }

            ctx_xy.putImageData(imageData, 0, 0);

            // z
            width = canvas_z.width;
            height = canvas_z.height;
            imageData = ctx_z.createImageData(width, height);
            data = imageData.data;

            for (let y = 0; y <= height; ++y) {
                for (let x = 0; x < width; ++x) {
                    const inverted_y = height - y;
                    const i = (inverted_y * width + x) * 4; // each pixel has 4 values: r, g, b, a

                    const normalized_y = y / height;
                    let selected_z;

                    switch (cookie.selected_z) {
                        case "r":
                            selected_z = byte_rgb.r;
                            data[i + 0] = normalized_y * 255;
                            data[i + 1] = byte_rgb.g;
                            data[i + 2] = byte_rgb.b;
                            break;
                        case "g":
                            selected_z = byte_rgb.g;
                            data[i + 0] = byte_rgb.r;
                            data[i + 1] = normalized_y * 255;
                            data[i + 2] = byte_rgb.b;
                            break;
                        case "b":
                            selected_z = byte_rgb.b;
                            data[i + 0] = byte_rgb.r;
                            data[i + 1] = byte_rgb.g;
                            data[i + 2] = normalized_y * 255;
                            break;
                        case "l": {
                            selected_z = Math.round((lch.l) * 255);
                            const lch_ = {
                                l: normalized_y,
                                c: lch.c,
                                h: lch.h,
                            };
                            const rgb_ = clamp_rgb(oklch_to_linear_srgb(lch_));

                            data[i + 0] = rgb_.r * 255;
                            data[i + 1] = rgb_.g * 255;
                            data[i + 2] = rgb_.b * 255;
                            break;
                        }
                        case "c": {
                            selected_z = Math.round((lch.c / 0.4) * 255);
                            const lch_ = {
                                l: lch.l,
                                c: normalized_y * 0.4,
                                h: lch.h,
                            };
                            const normalized_rgb_ = clamp_rgb(oklch_to_linear_srgb(lch_));

                            data[i + 0] = normalized_rgb_.r * 255;
                            data[i + 1] = normalized_rgb_.g * 255;
                            data[i + 2] = normalized_rgb_.b * 255;
                            break;
                        }
                        case "h": {
                            selected_z = Math.round(((lch.h + Math.PI) / (2 * Math.PI)) * 255);
                            const lch_ = {
                                l: lch.l,
                                c: lch.c,
                                h: normalized_y * 2 * Math.PI - Math.PI,
                            };
                            const normalized_rgb_ = clamp_rgb(oklch_to_linear_srgb(lch_));

                            data[i + 0] = normalized_rgb_.r * 255;
                            data[i + 1] = normalized_rgb_.g * 255;
                            data[i + 2] = normalized_rgb_.b * 255;
                            break;
                        }
                    }

                    data[i + 3] = 255;

                    if (selected_z == y) {
                        const data_rgb = {
                            r: data[i + 0] / 255,
                            g: data[i + 0] / 255,
                            b: data[i + 0] / 255,
                        };
                        const lab = linear_srgb_to_oklab(data_rgb);
                        if (lab.l > 0.85) {
                            data[i + 0] = 0;
                            data[i + 1] = 0;
                            data[i + 2] = 0;
                        } else {
                            data[i + 0] = 255;
                            data[i + 1] = 255;
                            data[i + 2] = 255;
                        }
                    }
                }
            }

            ctx_z.putImageData(imageData, 0, 0);
        }

        // color functions
        function clamp_rgb(c) {
            let clamped_r = c.r;
            let clamped_g = c.g;
            let clamped_b = c.b;
            let was_clamped = false;

            if (clamped_r < 0) {
                clamped_r = 0;
                was_clamped = true;
            }
            if (clamped_r > 1) {
                clamped_r = 1;
                was_clamped = true;
            }
            if (clamped_g < 0) {
                clamped_g = 0;
                was_clamped = true;
            }
            if (clamped_g > 1) {
                clamped_g = 1;
                was_clamped = true;
            }
            if (clamped_b < 0) {
                clamped_b = 0;
                was_clamped = true;
            }
            if (clamped_b > 1) {
                clamped_b = 1;
                was_clamped = true;
            }

            if (was_clamped && !cookie.clamp_invalid_colors) {
                return {
                    r: 1,
                    g: 0,
                    b: 1,
                };
            } else {
                return {
                    r: clamped_r,
                    g: clamped_g,
                    b: clamped_b,
                };
            }

        }

        function linear_srgb_to_oklch(c) {
            return oklab_to_oklch(linear_srgb_to_oklab(c));
        }

        function oklch_to_linear_srgb(c) {
            return oklab_to_linear_srgb(oklch_to_oklab(c));
        }

        function linear_srgb_to_oklab(c) {
            const l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;
            const m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;
            const s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;

            const l_ = Math.cbrt(l);
            const m_ = Math.cbrt(m);
            const s_ = Math.cbrt(s);

            return {
                l: 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,
                a: 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,
                b: 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_,
            };
        }

        function oklab_to_linear_srgb(c) {
            const l_ = c.l + 0.3963377774 * c.a + 0.2158037573 * c.b;
            const m_ = c.l - 0.1055613458 * c.a - 0.0638541728 * c.b;
            const s_ = c.l - 0.0894841775 * c.a - 1.2914855480 * c.b;

            const l = l_ * l_ * l_;
            const m = m_ * m_ * m_;
            const s = s_ * s_ * s_;

            return {
                r: +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,
                g: -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,
                b: -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s,
            };
        }

        function oklab_to_oklch(c) {
            return {
                l: c.l,
                c: Math.sqrt(c.a * c.a + c.b * c.b),
                h: Math.atan2(c.b, c.a),
            };
        }

        function oklch_to_oklab(c) {
            return {
                l: c.l,
                a: c.c * Math.cos(c.h),
                b: c.c * Math.sin(c.h),
            }
        }

        // cookie functions
        function read_cookie() {
            let cookie_exists = false;
            const cookies = document.cookie.split("; ");
            for (let c of cookies) {
                const [key, value] = c.split("=");
                if (key === cookie_name) {
                    try {
                        cookie = JSON.parse(value);
                        cookie_exists = true;
                    } catch (e) {
                    }

                    break;
                }
            }

            if (!cookie_exists) {
                set_cookie_to_default();
            }

            const cookie_string = JSON.stringify(cookie);
        }

        function save_cookie() {
            // get expiration date 1 week from now
            const date = new Date();
            date.setDate(date.getDate() + 7);
            const expiration_date = date.toUTCString();

            const cookie_data = JSON.stringify(cookie);

            document.cookie = `${cookie_name}=${cookie_data}; path=/; expires=${expiration_date}`
            console.log(document.cookie);
        }

        function clear_cookie() {
            document.cookie = `${cookie_name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
        }
    </script>
</body>
</html>
